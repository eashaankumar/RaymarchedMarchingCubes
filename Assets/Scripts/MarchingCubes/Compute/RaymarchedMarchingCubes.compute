#pragma kernel CSMain
#pragma kernel DensityKernel

#include "Utils/Noise.compute"
#include "Utils/HelperMath.compute"
#include "Utils/MarchingCubes.compute"

RWTexture2D<float4> Destination;
RWTexture3D<float> Density;
RWTexture3D<float> WaterDensity;
Texture2D<float4> SandTexture; SamplerState samplerSandTexture;
Texture2D<float4> WaterTexture; SamplerState samplerWaterTexture;

RWStructuredBuffer<uint> voxels;

RWStructuredBuffer<int3> mapPosCenter; // tracks id of voxel looked at by center pixel

float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;
float3 _LightDirection; // must be normalized!
// colors
float3 _AmbientColor;
float3 _GrassColor;
float3 _SandColor;
float3 _WaterColorShallow;
float3 _WaterColorDeep;
float _WaterDensityFalloff;
float3 _DirtColor;
float _Scale;
float _Impact;
float _Octaves;
float3 noisePosition = float3(0,0,0);
int _Terraforming;
float _BrushStrength;
int _BrushSize;
float _WaveBreakDepth;
float _Time;
float _SpecularStrength;
float3 _SunColor;

// rendering
bool _RenderOdds;

// atmosphere
float _AtmosphereRadius;
float _OceanRadius;
float _AtmosphereDensityFalloff;
int _OpticalDepthSteps;
int _AtmosphereSteps;
float3 _ScatterCoefficients = float3(700, 530, 440);

static const float epsilon = 0.001;
static const int MAX_RAY_VOX_TRAVERSE_COUNT = 500;
static const int MAX_SHADOW_RAY_VOX_TRAVERSE_COUNT = 50;

//float planetRadius = 100; // make sure they are synced!
static const float3 planetCenter = float3(0,0,0);
float planetRadius = 250;

static const int numThreads = 8;

float ridgedNoise(float3 p)
{
    float3 noise = abs(snoise(p));
    return 1.0f - noise;
}

float ridgedNoiseWave(float3 p)
{
    float3 noise = abs(snoise(normalize(p) + _Time/200 * _Scale) * _Impact);
    return 1.0f - noise;
}

float ridgedNoise2(float3 p, int octaves, int lacunarity, int gain)
{
    float noise = 1 - abs(snoise(p));
    for (int i = 1; i < octaves; i++)
    {
        noise += snoise(p * lacunarity * i) / (gain * i);
    }
    return noise;
}

float getPlanetNoise(int3 p)
{
    float3 worldPos = p;
    float d = distance(worldPos, planetCenter);
    return lerp(-1, 1, saturate(d / (planetRadius * 2)));
}

float density(int3 p)
{
    float noise = getPlanetNoise(p);
    float den = Density[p + int3(1,1,1) * 1000/2];
    return noise + den;
}

float waterDensity(int3 p)
{
    return WaterDensity[p + int3(1, 1, 1) * 1000 / 2];
}

float getNoise(int3 p)
{
    float3 worldPos = p;
    float3 pp = worldPos + noisePosition;
    return ridgedNoise2(pp * _Scale, _Octaves, 2.0, 2.0) * _Impact;
}

float getWaterNoise(int3 p)
{
    float3 worldPos = p - float3(1, 1, 1) * 1000 / 2;
    float dis = distance(worldPos, planetCenter);
    float r = saturate(dis / _OceanRadius);
    return exp(-(1 - r)) * 2 - 1;
}


int getBit(int3 v, int t)
{
    if (t == 0)
    {
        return density(v) < 0 ? 0 : 1;
    }
    else 
    {
        return waterDensity(v) < 0 ? 0 : 1;
    }
}

static int cellCase(int3 v0, int t)
{
    int v0x = v0.x, v0y = v0.y, v0z = v0.z;
    int3 v1 = int3(v0x, v0y + 1, v0z);
    int3 v2 = int3(v0x + 1, v0y + 1, v0z);
    int3 v3 = int3(v0x + 1, v0y, v0z);
    int3 v4 = int3(v0x, v0y, v0z + 1);
    int3 v5 = int3(v0x, v0y + 1, v0z + 1);
    int3 v6 = int3(v0x + 1, v0y + 1, v0z + 1);
    int3 v7 = int3(v0x + 1, v0y, v0z + 1);

    int caseByte = getBit(v7, t) << 7 | getBit(v6, t) << 6 |
        getBit(v5, t) << 5 | getBit(v4, t) << 4 |
        getBit(v3, t) << 3 | getBit(v2, t) << 2 |
        getBit(v1, t) << 1 | getBit(v0, t);
    return caseByte;
}

int3 CubeCornersToChunkNoiseGridPoints(int corner, int3 cubePos)
{
    return cornerToCubeVertex[corner] + cubePos;
}

float InterpolateTriangleVertexOnCubeEdge(int3 cornerA, int3 cornerB, int t)
{
    if (t == 0)
    {
        return invLerp(density(cornerA), density(cornerB), 0.0);
    }
    else
    {
        return invLerp(waterDensity(cornerA), waterDensity(cornerB), 0.0);
    }
}

float3 NoiseGridToWorldPos(int3 p)
{
    return float3(float(p.x), float(p.y), float(p.z));
}

static const float2 normalOffset = float2(1, 0);

float3 calculateNormal(int3 coord)
{
    
    float dx = density(coord + normalOffset.xyy) - density(coord - normalOffset.xyy);
    float dy = density(coord + normalOffset.yxy) - density(coord - normalOffset.yxy);
    float dz = density(coord + normalOffset.yyx) - density(coord - normalOffset.yyx);
    return normalize(float3(dx, dy, dz));
    //return normalize(coord);
}

Vertex VertexFromInterpolatedNoise(int edgeId, int3 cubePos, int t)
{
    Vertex v;
    int2 edgeCorners = edgeToCorners[edgeId];
    int3 cornerA = CubeCornersToChunkNoiseGridPoints(edgeCorners.x, cubePos);
    int3 cornerB = CubeCornersToChunkNoiseGridPoints(edgeCorners.y, cubePos);
    float time = InterpolateTriangleVertexOnCubeEdge(cornerA, cornerB, t);
    float3 cornerAWorld = NoiseGridToWorldPos(cornerA);
    float3 cornerBWorld = NoiseGridToWorldPos(cornerB);
    v.position = lerp(cornerAWorld, cornerBWorld, time);
    
    float3 normalA = calculateNormal(cornerA);
    float3 normalB = calculateNormal(cornerB);
    v.normal = normalize(lerp(normalA, normalB, time));
    return v;
}

VoxelTris generateTriangle(int3 id, int dtype)
{
    int caseByte = cellCase(id, dtype);
    int numTris = caseToNumPolys[caseByte];
    VoxelTris vTris;
    vTris.numTris = numTris;
    // Dummy
    Triangle dummy;
    Vertex dummyV;
    dummyV.position = float3(0, 0, 0);
    dummyV.normal = float3(0, 0, 0);
    dummy.vertexA = dummyV;
    dummy.vertexB = dummyV;
    dummy.vertexC = dummyV;
    vTris.triangles[0] = vTris.triangles[1] = vTris.triangles[2] = vTris.triangles[3] = vTris.triangles[4] = vTris.triangles[5] = dummy;
    for (int t = 0; t < numTris; t++)
    {
        int edgesOfTri[3] = fromVec2ECL(caseByte, t);

        Vertex triVertexOnEdge1 = VertexFromInterpolatedNoise(edgesOfTri[0], id, dtype);
        Vertex triVertexOnEdge2 = VertexFromInterpolatedNoise(edgesOfTri[1], id, dtype);
        Vertex triVertexOnEdge3 = VertexFromInterpolatedNoise(edgesOfTri[2], id, dtype);
        Triangle tri;
        tri.vertexA = triVertexOnEdge1;
        tri.vertexB = triVertexOnEdge2;
        tri.vertexC = triVertexOnEdge3;

        //triangles.Append(tri);
        vTris.triangles[t] = tri;
    }
    return vTris; 
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////

Ray CreateRay(float3 origin, float3 direction) {
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    return ray;
}

Ray CreateCameraRay(float2 uv) {
    float3 origin = mul(_CameraToWorld, float4(0, 0, 0, 1)).xyz;
    float3 direction = mul(_CameraInverseProjection, float4(uv, 0, 1)).xyz;
    direction = mul(_CameraToWorld, float4(direction, 0)).xyz;
    direction = normalize(direction); 
    return CreateRay(origin, direction);
}


bool getVoxel(int3 c)
{
    /*float3 p = float3(c)+float3(1, 1, 1) * 0.5;
    const float3 off = float3(2134, 213, 24);
    float d = distance(p, planetCenter);
    //float height = (snoise(normalize(p) * scale)) * amplitude;
    float3 pp = p + noisePosition;
    float noise = lerpF(-1.0, 1.0, d / (100 * 2));
    //return noise + (ridgedNoise2(normalize(pp * surfaceNoiseScale), 3, 2.0, 2.0) * 2 - 1) * surfaceNoiseImpact < 0;*/
    //return density(c) < 0;
    return false;
    //return noise < 0;
    //int i = to1D(c.x, c.y, c.z);
    //if (i < 0 || i >= voxelsPerAxis * voxelsPerAxis * voxelsPerAxis) return false;
   // return voxels[i] != 0;
}

const float sandHeight = 5;

float3 getColorAtVoxel(float3 p)
{
    //float3 p = float3(mapPos)+float3(1, 1, 1) * 0.5;
    float planetHeight = distance(p, planetCenter) - planetRadius - epsilon;
    if (planetHeight < sandHeight) return _SandColor;
    if (planetHeight < 10) return _DirtColor;
    if (planetHeight < 15) return _GrassColor;
    return float3(1, 1, 1);
}

//static const float MAX_FLOAT = 3.402823466e+38F;

// steps through solid voxel and detects hit with triangle
// start: worldPos of ray entry into voxel
// end: worldPos of ray exit out of voxel
CheckRayHitsTriangle hitsSurface(int3 mapPos, float3 start, float3 dir, float3 end, int t)
{
    CheckRayHitsTriangle hits;
    VoxelTris triangles = generateTriangle(mapPos, t);
    if (triangles.numTris == 0)
    {
        hits.hits = false;
        return hits;
    }
    //float maxDst = distance(start, end) - epsilon;
    float maxDst = length(end) - epsilon;
    float d = 0 + epsilon;
    while (d < maxDst)
    {
        float3 p = start + dir * d;
        SDFTriRes res = sdfTris(triangles, p);
        d += res.sdf;
        if (res.sdf < epsilon)
        {
            hits.hits = true;
            hits.triIndex = res.triI;
            hits.d = d;
            return hits;
        }
    }
    hits.hits = false;
    return hits;
}

float3 getVoxelExitOffset(float3 sideDist, float3 deltaDist)
{
    if (sideDist.x < sideDist.y) {
        if (sideDist.x < sideDist.z) {
            return float3(deltaDist.x, 0, 0);
        }
        else {
            return float3(0,0,deltaDist.z);
        }
    }
    else {
        if (sideDist.y < sideDist.z) {
            return float3(0,deltaDist.y,0);
        }
        else {
            return float3(0,0,deltaDist.z);
        }
    }
}

bool isVoxelInBrushRadius(int3 mapPos)
{
    int3 offset = mapPos - mapPosCenter[0];
    return (offset.x >= -_BrushSize && offset.x <= _BrushSize
        && offset.y >= -_BrushSize && offset.y <= _BrushSize
        && offset.z >= -_BrushSize && offset.z <= _BrushSize);
}

void terraform(int3 mapPos, int2 id, int width, int height)
{
    if (id.x == width / 2 && id.y == height / 2)
    {
        for (int x = -_BrushSize; x <= _BrushSize; x++)
        {
            for (int y = -_BrushSize; y <= _BrushSize; y++)
            {
                for (int z = -_BrushSize; z <= _BrushSize; z++)
                {
                    int3 offset = int3(x, y, z);
                    if (length(offset + float3(1, 1, 1) / 2) > _BrushSize) continue;
                    float dis = length(offset);
                    Density[mapPos + offset + int3(1, 1, 1) * 1000 / 2] += _BrushStrength * exp(-dis / _BrushSize) * _Terraforming;
                }
            }
        }
    }
}

RaymarchDDAResult raymarchDDA(float3 o, float3 dir, int maxStepCount)
{
    // https://www.shadertoy.com/view/4dX3zl
    float3 p = o;
    // which box of the map we're in
    int3 mapPos = int3(floor(p));
    // length of ray from one xyz-side to another xyz-sideDist
    float3 deltaDist = abs(float3(1, 1, 1) * length(dir) / dir);
    int3 rayStep = int3(sign(dir));
    // length of ray from current position to next xyz-side
    float3 sideDist = (sign(dir) * (float3(mapPos.x, mapPos.y, mapPos.z) - o) + (sign(dir) * 0.5) + 0.5) * deltaDist;
    bool3 mask;
    bool miss = false;
    float pathLength = 0;
    CheckRayHitsTriangle terrainHits, waterHits;
    bool isWaterRefracted = false;
    float3 waterSurfaceNorm = float3(0, 0, 0);
    float3 waterRefractedDir = float3(0, 0, 0);
    float totalDistThroughWater = 0;
    bool isTravelingThroughWater = false;
    float3 waterEnterPos = float3(0, 0, 0);
    for (int i = 0; i < maxStepCount; i++) {
        ///////////////////
        // Hit Detection //
        ///////////////////
        float3 startPoint = o + dir * pathLength;
        float3 travelDir = getVoxelExitOffset(sideDist, deltaDist);
        float3 endPoint = startPoint + travelDir;
        float maxDstThroughVoxel = length(travelDir);

        // Increament dis through water
        //if (isTravelingThroughWater && !waterHits.hits)
        //{
        //   totalDistThroughWater += maxDstThroughVoxel;
        //}

        terrainHits = hitsSurface(mapPos, startPoint, dir, endPoint, 0); // check terraing hit
        waterHits = hitsSurface(mapPos, startPoint, dir, endPoint, 1); // check water hit

        float3 waterSurfaceHitPoint = o + dir * (pathLength + waterHits.d);

        if (waterHits.hits)
        {
            // water surface normal
            VoxelTris waterMeshTris = generateTriangle(mapPos, 1); // water mesh
            Triangle wT = waterMeshTris.triangles[waterHits.triIndex];
            float3 triCoords = barycentricCoords(wT, waterSurfaceHitPoint);
            waterSurfaceNorm = normalize(wT.vertexA.normal * triCoords.x + wT.vertexB.normal * triCoords.y + wT.vertexC.normal * triCoords.z);
        }

        // Case 1: terrain Voxel only
        if (terrainHits.hits && !waterHits.hits)
        {
            // no water will be rendered since terrain is opaque
            if (isTravelingThroughWater)
            {
                float3 terrainSurfaceHitPoint = o + dir * (pathLength + terrainHits.d);
                totalDistThroughWater += distance(waterEnterPos, terrainSurfaceHitPoint);
            }
            break;
        }
        // Case 2: water Voxel only
        else if (!terrainHits.hits && waterHits.hits)
        {
            // water is translucent, so continue ray marching with refracted ray
            //waterSurfaceNorm = calculateNormal(mapPos);

            float lookDirRelToWaterSurface = dot(waterSurfaceNorm, dir);
            if (lookDirRelToWaterSurface < 0)
            {
                // entering water mesh
                float maxDst = distance(startPoint, endPoint) - epsilon;
                //totalDistThroughWater += maxDst - waterHits.d;
                isTravelingThroughWater = true;
                waterEnterPos = waterSurfaceHitPoint;
            }
            else
            {
                // exiting water mesh
                // distance traveled till this voxel
                totalDistThroughWater += distance(waterEnterPos, waterSurfaceHitPoint);
                isTravelingThroughWater = false;
            }

            //float _WaterRefractionIndex = 1.333;
            //waterRefractedDir = normalize(refract(dir, waterSurfaceNorm, _WaterRefractionIndex));
            waterRefractedDir = normalize(lerp(dir, -waterSurfaceNorm, 0.5));
            isWaterRefracted = true;
            // update deltaDist, rayStep, sideDist
            //deltaDist = abs(float3(1, 1, 1) * length(waterRefractedDir) / waterRefractedDir);
            //rayStep = int3(sign(waterRefractedDir));
            //sideDist = (sign(waterRefractedDir) * (float3(mapPos.x, mapPos.y, mapPos.z) - o) + (sign(waterRefractedDir) * 0.5) + 0.5) * deltaDist;
            // store hit and refraction details
            // continue raymarching
        }
        // Case 3: Neither terrain voxel nor water voxel
            // continue raymarching
        // Case 4: Both terrain voxel and water voxel
        else if (terrainHits.hits && waterHits.hits)
        {
            // Case 4A: terrain hit before water
            if (terrainHits.d < waterHits.d)
            {
                if (isTravelingThroughWater)
                {

                }
                break;
            }
            else {
                // Case 4B: water hit before terrain
                isWaterRefracted = true;
                totalDistThroughWater += terrainHits.d - waterHits.d;
                isTravelingThroughWater = true;
                break;
            }
        }
        //////////////////////////
        // Continue raymarching //
        //////////////////////////
        if (sideDist.x < sideDist.y) {
            if (sideDist.x < sideDist.z) {
                pathLength = sideDist.x;
                sideDist.x += deltaDist.x;
                mapPos.x += rayStep.x;
                mask = bool3(true, false, false);
            }
            else {
                pathLength = sideDist.z;
                sideDist.z += deltaDist.z;
                mapPos.z += rayStep.z;
                mask = bool3(false, false, true);
            }
        }
        else {
            if (sideDist.y < sideDist.z) {
                pathLength = sideDist.y;
                sideDist.y += deltaDist.y;
                mapPos.y += rayStep.y;
                mask = bool3(false, true, false);
            }
            else {
                pathLength = sideDist.z;
                sideDist.z += deltaDist.z;
                mapPos.z += rayStep.z;
                mask = bool3(false, false, true);
            }
        }
        if (i == maxStepCount - 1)
        {
            miss = true;
        }
    }

    RaymarchDDAResult result;
    result.mapPos = mapPos;
    result.miss = miss;
    result.pathLength = pathLength;
    //result.normal = normalize(hits.tri.vertexA.normal + hits.tri.vertexB.normal + hits.tri.vertexC.normal);
    result.triIndex = terrainHits.triIndex;
    result.voxelD = terrainHits.d;
    result.isWaterRefracted = isWaterRefracted;
    result.waterSurfaceNorm = waterSurfaceNorm;
    result.waterRefractedDir = waterRefractedDir;
    result.totalDistThroughWater = totalDistThroughWater;
    return result;
}

bool isShadow(Ray camRay, float3 normal, float3 hitPoint)
{
    //float3 shadowRayDir = normalize(reflect(-camRay.direction, normal));
    float3 shadowRayDir = -_LightDirection;
    float3 o = hitPoint - camRay.direction * epsilon * 100;
    RaymarchDDAResult shadowResult = raymarchDDA(o + shadowRayDir * (epsilon * 2), shadowRayDir, MAX_SHADOW_RAY_VOX_TRAVERSE_COUNT);
    return !shadowResult.miss;
}

float densityAtPoint(float3 densitySamplePoint)
{
    float heightAboveSurface = length(densitySamplePoint - planetCenter) - planetRadius;
    float height01 = heightAboveSurface / (_AtmosphereRadius - planetRadius);
    return exp(-height01 * _AtmosphereDensityFalloff) * (1 - height01);
}

float opticalDepth(float3 rayOrigin, float3 rayDir, float rayLength)
{
    float3 densitySamplePoint = rayOrigin;
    float stepsize = rayLength / (_OpticalDepthSteps - 1);
    float opticalDepth = 0;
    for (int i = 0; i < _OpticalDepthSteps; i++)
    {
        float localDensity = densityAtPoint(densitySamplePoint);
        opticalDepth += localDensity * stepsize;
        densitySamplePoint += rayDir * stepsize;
    }
    return opticalDepth;
}

float3 calculateLight(float3 rayOrigin, float3 rayDir, float3 rayLength, float3 originalCol)
{
    float3 inScatterPoint = rayOrigin;
    float stepSize = rayLength / (_AtmosphereSteps - 1);
    float3 inScatterLight = 0;
    float viewRayOpticalDepth = 0;

    for (int i = 0; i < _AtmosphereSteps; i++)
    {
        float sunRayLength = raySphere(planetCenter, _AtmosphereRadius, inScatterPoint, -_LightDirection).y;
        float sunRayOpticalDepth = opticalDepth(inScatterPoint, -_LightDirection, sunRayLength);
        viewRayOpticalDepth = opticalDepth(inScatterPoint, -rayDir, stepSize * i);
        float3 transmittance = exp(-(sunRayOpticalDepth + viewRayOpticalDepth) * _ScatterCoefficients);
        float localDensity = densityAtPoint(inScatterPoint);
        inScatterLight += localDensity * transmittance * _ScatterCoefficients * stepSize;
        inScatterPoint += rayDir * stepSize;
    }
    float originalColTransmittance = exp(-viewRayOpticalDepth);
    return (originalCol * originalColTransmittance) + inScatterLight * float3(1.1,1.1,1.1) + originalCol;
}

/*int findMatchingTriangleIndex(Triangle t, Triangle tris[6], int numTris)
{
    if (numTris == 0 || numTris >= 6) return -1;
    int minI = 0;
    float minDot = 10000;
    for (int i = 0; i < numTris; i++)
    {
        float vertexADot = abs(dot(t.vertexA.position, tris[i].vertexA.position));
        float vertexBDot = abs(dot(t.vertexB.position, tris[i].vertexB.position));
        float vertexCDot = abs(dot(t.vertexC.position, tris[i].vertexC.position));
        float currDot = vertexADot + vertexBDot + vertexCDot;
        if (currDot < minDot)
        {
            minDot = currDot;
            minI = i;
        }
    }

    return minI;
}*/

float sandNoise(float3 p)
{
    float grainySandNoise = max((ridgedNoise2(p * 10, 3, 2, 1.5)) * 0.5 + 0.5, 0.99);
    //float wavySandNoise = max(( sin((hitPoint.x+hitPoint.y+hitPoint.z) * 10) + ridgedNoise(hitPoint * 2)) * 0.5 + 0.5, 0.1);
    return grainySandNoise;
}

float3 GetColorAtRaymarchResult(RaymarchDDAResult res, Ray camRay)
{
    float3 color = float3(0, 0, 0);
    float3 surfaceColor = float3(0, 0, 0);
    float3 voxelColor = float3(0, 0, 0);
    float3 diffuseColor = float3(0, 0, 0);
    float disToSurface = 0;
    float3 hitPoint = camRay.origin + camRay.direction * (res.pathLength + res.voxelD);

    if (res.isWaterRefracted)
    {
        float depthAmt = saturate(1-exp(_WaterDensityFalloff * -res.totalDistThroughWater));
        return lerp(_WaterColorShallow, _WaterColorDeep, depthAmt);
        //return res.waterSurfaceNorm * 0.5 + 0.5;
    }

    if (!res.miss) {
        VoxelTris vt = generateTriangle(res.mapPos, 0); // terrain
        Triangle t = vt.triangles[res.triIndex];
        float3 triCoords = barycentricCoords(t, hitPoint);

        // If flatshading
        float3 normal = calculateNormal(res.mapPos);
        // if smooth shading
        normal = normalize(t.vertexA.normal * triCoords.x + t.vertexB.normal * triCoords.y + t.vertexC.normal * triCoords.z);

        // material
        float sandNoiseDisappearingFallOff = 0.1; // higher = sooner it disappears
        float sandNois = lerp(1, sandNoise(hitPoint), exp(sandNoiseDisappearingFallOff * -abs(res.pathLength)) );
        //float sandFadeOutDis = 10;
        //if (res.pathLength < sandFadeOutDis)
        { // ignore if camera is too far away
            //float2 off = float2(0.01, 0);
            //float3 sandNorm = normalize(float3(sandNoise(hitPoint + off.xyy) - sandNoise(hitPoint - off.xyy),
            //    sandNoise(hitPoint + off.yxy) - sandNoise(hitPoint - off.yxy),
            //    sandNoise(hitPoint + off.yyx) - sandNoise(hitPoint - off.yyx)));

            //normal = normalize(normal + sandNorm);
        }

        disToSurface = res.pathLength + res.voxelD;
        float diff = dot(normal, -_LightDirection);
        float diffIntensity = 1;
        //voxelColor = getColorAtVoxel(hitPoint);

        //voxelColor = SandTexture.SampleLevel(samplerSandTexture, triCoords.xy, 0);
        
        voxelColor = (sandNois) * _SandColor;

        float3 diffuse = float3(1, 1, 1) * diffIntensity;
        diffuseColor = saturate(diff * diffuse);

        float fogAmt = pow(exp(-1 / res.pathLength), 10);
        float3 fog = fogAmt * float3(1, 1, 1);

        // shadow
        float3 shadowColor = float3(1, 1, 1);
        bool shadow = isShadow(camRay, normal, hitPoint);
        if (shadow) shadowColor *= 0.5;

        surfaceColor = (diffuseColor + _AmbientColor) * voxelColor * shadowColor;
        

        //res.mapPos.x == mapPosCenter[0].x && res.mapPos.y == mapPosCenter[0].y && res.mapPos.z == mapPosCenter[0].z
        /*if (isVoxelInBrushRadius(res.mapPos))
        {
            float brushdis = distance(res.mapPos, mapPosCenter[0]);
            color = color + float3(1, 0, 0) * (1 - brushdis / _BrushSize);
        }*/

        //color = float3(1, 1, 1);
        //color = float3(1, 1, 1);
        // depth blur
        //color *= (1 - d / maxStepCount * 1.75);
        color = normal * 0.5 + 0.5;
    }

    color = surfaceColor;

    // ocean
    /*float waveNoise = ridgedNoiseWave(hitPoint);
    float2 oceanRaySphere = raySphere(planetCenter, _OceanRadius, camRay.origin, camRay.direction);
    float3 oceanColor = float3(0, 0, 0);
    float disToWaterSurface = oceanRaySphere.x;
    float disThroughOcean = 0;
    float oceanNormalNoise = waveNoise * 10;
    float3 oceanNormal = hitPoint - planetCenter;
    if (oceanRaySphere.y > 0 && disToWaterSurface < MAX_RAY_VOX_TRAVERSE_COUNT/2)
    {
        // Ocean not in path of ray

        if (res.miss)
        {
            disThroughOcean = oceanRaySphere.y / (_OceanRadius * 2);
            oceanNormal = normalize(oceanNormal + oceanNormalNoise * exp(1/ disThroughOcean));

            oceanColor = lerp(_WaterColorShallow, _WaterColorDeep, disThroughOcean);
            oceanColor = saturate(oceanColor);
            color = oceanColor;
        }
        else if (disToWaterSurface < disToSurface)
        {
            // Ocean visible
            disThroughOcean = disToSurface - disToWaterSurface;
            oceanNormal = normalize(oceanNormal + oceanNormalNoise * exp(1 / disThroughOcean));

            float disT = 1 - disToWaterSurface / disToSurface;
            //if (disToWaterSurface > 0)
            {
                //float2 uv = sphericalToUV(hitPoint, planetCenter) * 100;
                //oceanColor = WaterTexture.SampleLevel(samplerWaterTexture, uv, 0);
            }
            //else 
            {
                oceanColor = lerp(_WaterColorShallow, _WaterColorDeep, disT);
            }
            // wavebreak
            //if (disThroughOcean <= _WaveBreakDepth)
            //{
            //    oceanColor = float3(1, 1, 1);
            //    color = saturate(oceanColor * 1 / disThroughOcean);
            //}
            //else
            {
                // diffuse
                float diff = max(dot(oceanNormal, -_LightDirection), 0.0);
                float3 diffuse = diff * _SunColor;
                // specular
                float3 reflectDir = reflect(-_LightDirection, oceanNormal);
                float spec = pow(max(dot(camRay.direction, reflectDir), 0.0), 32);
                float3 specular = _SpecularStrength * spec * _SunColor;
                //oceanColor *= waveNoise;
                oceanColor = saturate((float3(1, 1, 1) * 0.25 + diffuse + specular) * oceanColor);
                //surfaceColor = (diffuseColor + _AmbientColor) * voxelColor * shadowColor;
                color = lerp(oceanColor, surfaceColor, saturate(1 / disThroughOcean));
            }
        }
    }*/
    
    // atmoshpere
    float2 atmosphereSphere = raySphere(planetCenter, _AtmosphereRadius, camRay.origin, camRay.direction);
    float dstToAtmosphere = atmosphereSphere.x;
    float dstThroughAtmosphere = disToSurface - dstToAtmosphere;
    if (res.miss) dstThroughAtmosphere = atmosphereSphere.y;
    if (dstThroughAtmosphere > 0)
    {
        const float atmos_epsilon = 0.0001;
        float3 pointInAtmosphere = camRay.origin + camRay.direction * (dstToAtmosphere + atmos_epsilon);
        color = calculateLight(pointInAtmosphere, camRay.direction, dstThroughAtmosphere - atmos_epsilon * 2, color);
    }

    return color;
}

float3 raymarchTri(Ray ray)
{
    float d = 0;
    float maxDst = 1000;
    bool hit = false;
    while (d < maxDst)
    {
        float3 p = ray.origin + ray.direction * d;
        float sdf = udTriangle(float3(0,0,0), float3(10,0,0), float3(0,10,0), p);
        //float sdf = sdSphere(p, 30, planetCenter);
        if (sdf < epsilon)
        {
            hit = true;
            break;
        }
        d += sdf;
    }
    if (!hit) return float3(0, 0, 0);
    return normalize(d/maxDst) * 0.5 + 0.5;
}

void blur(uint2 id, uint width, uint height)
{
    float4 result = float4(0,0,0,0);
    int blurRadius = 0;
    int count = 0;
    for (int x = -blurRadius; x <= blurRadius; x++)
    {
        for (int y = -blurRadius; y <= blurRadius; y++)
        {
            int2 offset = id.xy + int2(x, y);
            if (offset.x < 0 || offset.y < 0 || offset.x >= width || offset.y >= height) continue;
            float d = distance(id.xy, offset.xy);
            result += Destination[id.xy + int2(x, y)] * gaussian(int2(x, y), 1);
            count++;
        }
    }
    //Destination[id.xy] = result;
}

bool shouldRayMarch(uint2 id, uint width, uint height)
{
    if (id.x == width / 2 && id.y == height / 2) return true;
    float off = distance(int2(width/2, height/2), id.xy);
    if (off <= _BrushSize) return true;
    bool odds = (_RenderOdds && !(id.x % 2 == 0 && id.y % 2 == 0));
    bool evens = (!_RenderOdds && (id.x % 2 == 0 && id.y % 2 == 0));
    return odds || evens;
}

[numthreads(numThreads, numThreads, 1)]
void CSMain(uint2 id : SV_DispatchThreadID)
{
    uint width, height;
    Destination.GetDimensions(width, height);

    if (shouldRayMarch(id, width, height))
    {
        float2 uv = id.xy / float2(width, height);
        uv += float2(sin(_Time) / width, cos(_Time) / height) * 0.01;

        // Background gradient

        // Raymarching:
        Ray ray = CreateCameraRay(uv * 2 - 1);

        float4 result = float4(ray.direction * 0.5 + 0.5, 0);

        RaymarchDDAResult res = raymarchDDA(ray.origin, ray.direction, MAX_RAY_VOX_TRAVERSE_COUNT);

        if (id.x == width / 2 && id.y == height / 2)
        {
            mapPosCenter[0] = res.mapPos;
        }

        result.xyz = GetColorAtRaymarchResult(res, ray);

        //result.xyz = raymarchTri(ray);

        Destination[id.xy] = result;
        blur(id, width, height);

        if (_Terraforming != 0)
        {
            terraform(res.mapPos, id, width, height);
        }
    }
}

[numthreads(numThreads, numThreads, numThreads)]
void DensityKernel(uint3 id : SV_DispatchThreadID)
{
    Density[id.xyz] = getNoise(id);
    WaterDensity[id.xyz] = getWaterNoise(id);
}
