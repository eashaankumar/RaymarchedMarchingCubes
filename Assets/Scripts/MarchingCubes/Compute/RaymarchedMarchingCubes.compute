#pragma kernel CSMain
#pragma kernel DensityKernel

#include "Noise.compute"


RWTexture2D<float4> Destination;
RWTexture3D<float> Density;
RWTexture3D<float> WaterDensity;
Texture2D<float4> SandTexture; SamplerState samplerSandTexture;
Texture2D<float4> WaterTexture; SamplerState samplerWaterTexture;

RWStructuredBuffer<uint> voxels;

RWStructuredBuffer<int3> mapPosCenter; // tracks id of voxel looked at by center pixel

float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;
float3 _LightDirection; // must be normalized!
// colors
float3 _AmbientColor;
float3 _GrassColor;
float3 _SandColor;
float3 _WaterColorShallow;
float3 _WaterColorDeep;
float _WaterDensityFalloff;
float3 _DirtColor;
float _Scale;
float _Impact;
float _Octaves;
float3 noisePosition = float3(0,0,0);
int _Terraforming;
float _BrushStrength;
int _BrushSize;
float _WaveBreakDepth;
float _Time;
float _SpecularStrength;
float3 _SunColor;

// rendering
bool _RenderOdds;

// atmosphere
float _AtmosphereRadius;
float _OceanRadius;
float _AtmosphereDensityFalloff;
int _OpticalDepthSteps;
int _AtmosphereSteps;
float3 _ScatterCoefficients = float3(700, 530, 440);

static const float PI = 3.1415925;

static const float epsilon = 0.001;
static const int MAX_RAY_VOX_TRAVERSE_COUNT = 500;
static const int MAX_SHADOW_RAY_VOX_TRAVERSE_COUNT = 50;

//float planetRadius = 100; // make sure they are synced!
static const float3 planetCenter = float3(0,0,0);
float planetRadius = 250;

static const int numThreads = 8;

////////////////////////////////////////// MARCHING CUBES ///////////////////////////////////////////////
struct Vertex {
    float3 position;
    float3 normal;
};

struct Triangle {
    Vertex vertexC;
    Vertex vertexB;
    Vertex vertexA;
};

static const float3 directions[16] = {
    float3(1, 1, 0),
    float3(-1, 1, 0),
    float3(1,-1, 0),
    float3(-1,-1, 0),
    float3(1, 0, 1),
    float3(-1, 0, 1),
    float3(1, 0,-1),
    float3(-1, 0,-1),
    float3(0, 1, 1),
    float3(0,-1, 1),
    float3(0, 1,-1),
    float3(0,-1,-1),

    float3(1, 1, 0),
    float3(-1, 1, 0),
    float3(0,-1, 1),
    float3(0,-1,-1)
};

static const int caseToNumPolys[256] = {
    0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 2, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 3,
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 3, 2, 3, 3, 2, 3, 4, 4, 3, 3, 4, 4, 3, 4, 5, 5, 2,
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 3, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 4,
    2, 3, 3, 4, 3, 4, 2, 3, 3, 4, 4, 5, 4, 5, 3, 2, 3, 4, 4, 3, 4, 5, 3, 2, 4, 5, 5, 4, 5, 2, 4, 1,
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 3, 2, 3, 3, 4, 3, 4, 4, 5, 3, 2, 4, 3, 4, 3, 5, 2,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 4, 3, 4, 4, 3, 4, 5, 5, 4, 4, 3, 5, 2, 5, 4, 2, 1,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 2, 3, 3, 2, 3, 4, 4, 5, 4, 5, 5, 2, 4, 3, 5, 4, 3, 2, 4, 1,
    3, 4, 4, 5, 4, 5, 3, 4, 4, 5, 5, 2, 3, 4, 2, 1, 2, 3, 3, 2, 3, 4, 2, 1, 3, 2, 4, 1, 2, 1, 1, 0
};

// 256 rows, 5 vec4s (ignore 4th component) representing edges
const static int edge_connect_list[256 * 15] = {
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1,
9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1,
2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1,
3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1,
1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1,
1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1,
3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1,
0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1,
3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1,
9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1,
4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1,
0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1,
4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1,
1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1,
3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1,
9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1,
2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1,
8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1,
11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1,
9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1,
4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1,
3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1,
1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1,
4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1,
4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1,
9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1,
0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1,
8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1,
1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1,
3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1,
5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1,
2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1,
9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1,
0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1,
0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1,
2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1,
10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1,
4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1,
5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1,
5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1,
9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1,
9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1,
0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1,
1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1,
9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1,
10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1,
8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1,
2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1,
7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1,
9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1,
2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1,
11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1,
9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1,
5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0,
11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0,
11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1,
10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1,
9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1,
1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1,
1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1,
9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1,
5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1,
2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1,
11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1,
0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1,
5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1,
6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1,
0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1,
3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1,
6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1,
5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1,
4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1,
1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1,
10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1,
6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1,
1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1,
8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1,
7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9,
3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1,
5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1,
0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1,
9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6,
8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1,
5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11,
0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7,
6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1,
10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1,
4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1,
10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1,
8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1,
1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1,
3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1,
0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1,
8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1,
10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1,
0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1,
3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1,
6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1,
9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1,
8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1,
3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1,
6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1,
7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1,
0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1,
10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1,
10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1,
1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1,
2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9,
7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1,
7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1,
2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1,
2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7,
1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11,
11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1,
8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6,
0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1,
7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1,
7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1,
0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1,
8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1,
10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1,
1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1,
2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1,
6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1,
7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1,
7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1,
2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1,
1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1,
10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1,
10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1,
0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1,
7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1,
6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1,
3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1,
8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1,
9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1,
6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1,
1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1,
4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1,
10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3,
8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1,
0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1,
1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1,
1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1,
8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1,
10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1,
4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3,
10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1,
4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1,
0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1,
5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1,
11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1,
9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1,
6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1,
7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1,
3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6,
7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1,
9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1,
3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1,
6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8,
9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1,
1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4,
4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10,
7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1,
6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1,
3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1,
0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1,
6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1,
1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1,
0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10,
11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5,
6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1,
5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1,
9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1,
1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8,
1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1,
1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6,
10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1,
0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1,
10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1,
11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1,
5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1,
10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1,
11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1,
0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1,
9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1,
7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2,
2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1,
8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1,
9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1,
9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2,
1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1,
0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1,
9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1,
9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1,
5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1,
5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1,
0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1,
10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4,
2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1,
0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11,
0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5,
9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1,
2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1,
5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1,
3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9,
5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1,
8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1,
0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1,
8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1,
9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1,
0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1,
1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1,
3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4,
4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1,
9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3,
11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1,
11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1,
2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1,
9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7,
3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10,
1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1,
4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1,
4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1,
4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1,
4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1,
3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1,
0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1,
3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1,
1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1,
3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1,
0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1,
3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1,
9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1,
2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1,
1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1,
0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
};

struct EdgeConnection
{
    int edges[3];
};

/// <summary>
/// Returns edge triplet given case if of voxel and poligon index desired from edge_connect_list
/// </summary>
/// <param name="caseId">[0,256)</param>
/// <param name="polygonI">[0, 4)</param>
/// <returns></returns>
static EdgeConnection fromVec2ECL(int caseId, int polygonI)
{
    EdgeConnection eC;
    int row = caseId;
    int col = polygonI * 3; // first element of 3d vector
    int index = col + row * 15;
    eC.edges[0] = edge_connect_list[index];
    eC.edges[1] = edge_connect_list[index + 1];
    eC.edges[2] = edge_connect_list[index + 2];
    return eC;
}


static const int3 cornerToCubeVertex[8] = {
    int3(0, 0, 0),
    int3(0, 1, 0),
    int3(1, 1, 0),
    int3(1, 0, 0),
    int3(0, 0, 1),
    int3(0, 1, 1),
    int3(1, 1, 1),
    int3(1, 0, 1)
};

static const int2 edgeToCorners[12] = {
    int2(0, 1),
    int2(1, 2),
    int2(3, 2),
    int2(0, 3),
    int2(4, 5),
    int2(5, 6),
    int2(7, 6),
    int2(4, 7),
    int2(0, 4),
    int2(1, 5),
    int2(2, 6),
    int2(3, 7)
};

static const int directionCount = 15;

float lerpF(float a, float b, float w) {
    return a + w * (b - a);
}

float ridgedNoise(float3 p)
{
    float3 noise = abs(snoise(p));
    return 1.0f - noise;
}

float ridgedNoiseWave(float3 p)
{
    float3 noise = abs(snoise(normalize(p) + _Time/200 * _Scale) * _Impact);
    return 1.0f - noise;
}

float ridgedNoise2(float3 p, int octaves, int lacunarity, int gain)
{
    float noise = 1 - abs(snoise(p));
    for (int i = 1; i < octaves; i++)
    {
        noise += snoise(p * lacunarity * i) / (gain * i);
    }
    return noise;
}

float getPlanetNoise(int3 p)
{
    float3 worldPos = p;
    float d = distance(worldPos, planetCenter);
    return lerp(-1, 1, saturate(d / (planetRadius * 2)));
}

float density(int3 p)
{
    float noise = getPlanetNoise(p);
    float den = Density[p + int3(1,1,1) * 1000/2];
    return noise + den;
}

float waterDensity(int3 p)
{
    return WaterDensity[p + int3(1, 1, 1) * 1000 / 2];
}

float getNoise(int3 p)
{
    float3 worldPos = p;
    float3 pp = worldPos + noisePosition;
    return ridgedNoise2(pp * _Scale, _Octaves, 2.0, 2.0) * _Impact;
}

float getWaterNoise(int3 p)
{
    float3 worldPos = p - float3(1, 1, 1) * 1000 / 2;
    float dis = distance(worldPos, planetCenter);
    float r = saturate(dis / _OceanRadius);
    return exp(-(1 - r)) * 2 - 1;
}


int getBit(int3 v, int t)
{
    if (t == 0)
    {
        return density(v) < 0 ? 0 : 1;
    }
    else 
    {
        return waterDensity(v) < 0 ? 0 : 1;
    }
}

static int cellCase(int3 v0, int t)
{
    int v0x = v0.x, v0y = v0.y, v0z = v0.z;
    int3 v1 = int3(v0x, v0y + 1, v0z);
    int3 v2 = int3(v0x + 1, v0y + 1, v0z);
    int3 v3 = int3(v0x + 1, v0y, v0z);
    int3 v4 = int3(v0x, v0y, v0z + 1);
    int3 v5 = int3(v0x, v0y + 1, v0z + 1);
    int3 v6 = int3(v0x + 1, v0y + 1, v0z + 1);
    int3 v7 = int3(v0x + 1, v0y, v0z + 1);

    int caseByte = getBit(v7, t) << 7 | getBit(v6, t) << 6 |
        getBit(v5, t) << 5 | getBit(v4, t) << 4 |
        getBit(v3, t) << 3 | getBit(v2, t) << 2 |
        getBit(v1, t) << 1 | getBit(v0, t);
    return caseByte;
}

int3 CubeCornersToChunkNoiseGridPoints(int corner, int3 cubePos)
{
    return cornerToCubeVertex[corner] + cubePos;
}

float invLerp(float from, float to, float value) {
    return (value - from) / (to - from);
}

float InterpolateTriangleVertexOnCubeEdge(int3 cornerA, int3 cornerB, int t)
{
    if (t == 0)
    {
        return invLerp(density(cornerA), density(cornerB), 0.0);
    }
    else
    {
        return invLerp(waterDensity(cornerA), waterDensity(cornerB), 0.0);
    }
}

float3 NoiseGridToWorldPos(int3 p)
{
    return float3(float(p.x), float(p.y), float(p.z));
}

static const float2 normalOffset = float2(1, 0);

float3 calculateNormal(int3 coord)
{
    
    float dx = density(coord + normalOffset.xyy) - density(coord - normalOffset.xyy);
    float dy = density(coord + normalOffset.yxy) - density(coord - normalOffset.yxy);
    float dz = density(coord + normalOffset.yyx) - density(coord - normalOffset.yyx);
    return normalize(float3(dx, dy, dz));
    //return normalize(coord);
}

Vertex VertexFromInterpolatedNoise(int edgeId, int3 cubePos, int t)
{
    Vertex v;
    int2 edgeCorners = edgeToCorners[edgeId];
    int3 cornerA = CubeCornersToChunkNoiseGridPoints(edgeCorners.x, cubePos);
    int3 cornerB = CubeCornersToChunkNoiseGridPoints(edgeCorners.y, cubePos);
    float time = InterpolateTriangleVertexOnCubeEdge(cornerA, cornerB, t);
    float3 cornerAWorld = NoiseGridToWorldPos(cornerA);
    float3 cornerBWorld = NoiseGridToWorldPos(cornerB);
    v.position = lerp(cornerAWorld, cornerBWorld, time);
    
    float3 normalA = calculateNormal(cornerA);
    float3 normalB = calculateNormal(cornerB);
    v.normal = normalize(lerp(normalA, normalB, time));
    return v;
}

float3 diff(float3 a, float3 b) {
    return float3(a.x - b.x, a.y - b.y, a.z - b.z);
}

float dot(float3 a, float3 b) {
    return a.x * b.x + a.y * b.y + a.z * b.z;
}

struct VoxelTris
{
    Triangle triangles[6];
    int numTris;
};

VoxelTris generateTriangle(int3 id, int dtype)
{
    int caseByte = cellCase(id, dtype);
    int numTris = caseToNumPolys[caseByte];
    VoxelTris vTris;
    vTris.numTris = numTris;
    // Dummy
    Triangle dummy;
    Vertex dummyV;
    dummyV.position = float3(0, 0, 0);
    dummyV.normal = float3(0, 0, 0);
    dummy.vertexA = dummyV;
    dummy.vertexB = dummyV;
    dummy.vertexC = dummyV;
    vTris.triangles[0] = vTris.triangles[1] = vTris.triangles[2] = vTris.triangles[3] = vTris.triangles[4] = vTris.triangles[5] = dummy;
    for (int t = 0; t < numTris; t++)
    {
        int edgesOfTri[3] = fromVec2ECL(caseByte, t);

        Vertex triVertexOnEdge1 = VertexFromInterpolatedNoise(edgesOfTri[0], id, dtype);
        Vertex triVertexOnEdge2 = VertexFromInterpolatedNoise(edgesOfTri[1], id, dtype);
        Vertex triVertexOnEdge3 = VertexFromInterpolatedNoise(edgesOfTri[2], id, dtype);
        Triangle tri;
        tri.vertexA = triVertexOnEdge1;
        tri.vertexB = triVertexOnEdge2;
        tri.vertexC = triVertexOnEdge3;

        //triangles.Append(tri);
        vTris.triangles[t] = tri;
    }
    return vTris; 
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////

struct Ray {
    float3 origin;
    float3 direction;
};

Ray CreateRay(float3 origin, float3 direction) {
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    return ray;
}

Ray CreateCameraRay(float2 uv) {
    float3 origin = mul(_CameraToWorld, float4(0, 0, 0, 1)).xyz;
    float3 direction = mul(_CameraInverseProjection, float4(uv, 0, 1)).xyz;
    direction = mul(_CameraToWorld, float4(direction, 0)).xyz;
    direction = normalize(direction); 
    return CreateRay(origin, direction);
}

float sdSphere(float3 p, float r, float3 c) { return length(p - c) - r; }

float dot2(float3 v) { return dot(v, v); }
float udTriangle(float3 v1, float3 v2, float3 v3, float3 p)
{
    // prepare data    
    float3 v21 = v2 - v1; float3 p1 = p - v1;
    float3 v32 = v3 - v2; float3 p2 = p - v2;
    float3 v13 = v1 - v3; float3 p3 = p - v3;
    float3 nor = cross(v21, v13);

    return sqrt( // inside/outside test    
        (sign(dot(cross(v21, nor), p1)) +
            sign(dot(cross(v32, nor), p2)) +
            sign(dot(cross(v13, nor), p3)) < 2.0)
        ?
        // 3 edges    
        min(min(
            dot2(v21 * clamp(dot(v21, p1) / dot2(v21), 0.0, 1.0) - p1),
            dot2(v32 * clamp(dot(v32, p2) / dot2(v32), 0.0, 1.0) - p2)),
            dot2(v13 * clamp(dot(v13, p3) / dot2(v13), 0.0, 1.0) - p3))
        :
        // 1 face    
        dot(nor, p1) * dot(nor, p1) / dot2(nor));
}
float udTriangle2(Triangle t, float3 p)
{
    return udTriangle(t.vertexA.position, t.vertexB.position, t.vertexC.position, p);
}


bool getVoxel(int3 c)
{
    /*float3 p = float3(c)+float3(1, 1, 1) * 0.5;
    const float3 off = float3(2134, 213, 24);
    float d = distance(p, planetCenter);
    //float height = (snoise(normalize(p) * scale)) * amplitude;
    float3 pp = p + noisePosition;
    float noise = lerpF(-1.0, 1.0, d / (100 * 2));
    //return noise + (ridgedNoise2(normalize(pp * surfaceNoiseScale), 3, 2.0, 2.0) * 2 - 1) * surfaceNoiseImpact < 0;*/
    //return density(c) < 0;
    return false;
    //return noise < 0;
    //int i = to1D(c.x, c.y, c.z);
    //if (i < 0 || i >= voxelsPerAxis * voxelsPerAxis * voxelsPerAxis) return false;
   // return voxels[i] != 0;
}

const float sandHeight = 5;

float3 getColorAtVoxel(float3 p)
{
    //float3 p = float3(mapPos)+float3(1, 1, 1) * 0.5;
    float planetHeight = distance(p, planetCenter) - planetRadius - epsilon;
    if (planetHeight < sandHeight) return _SandColor;
    if (planetHeight < 10) return _DirtColor;
    if (planetHeight < 15) return _GrassColor;
    return float3(1, 1, 1);
}

//static const float MAX_FLOAT = 3.402823466e+38F;

struct SDFTriRes
{
    float sdf;
    int triI;
};

SDFTriRes sdfTris(VoxelTris tris, float3 p)
{
    SDFTriRes res;
    res.triI = 0;
    res.sdf = udTriangle2(tris.triangles[0], p);
    float sdf = 0;
    if (tris.numTris >= 2) 
    { 
        sdf = min(res.sdf, udTriangle2(tris.triangles[1], p)); 
        if (sdf < res.sdf) res.triI = 1;
        res.sdf = sdf;
    }
    if (tris.numTris >= 3)
    {
        sdf = min(res.sdf, udTriangle2(tris.triangles[2], p));
        if (sdf < res.sdf) res.triI = 2;
        res.sdf = sdf;
    }
    if (tris.numTris >= 4)
    {
        sdf = min(res.sdf, udTriangle2(tris.triangles[3], p));
        if (sdf < res.sdf) res.triI = 3;
        res.sdf = sdf;
    }
    if (tris.numTris >= 5)
    {
        sdf = min(res.sdf, udTriangle2(tris.triangles[4], p));
        if (sdf < res.sdf) res.triI = 4;
        res.sdf = sdf;
    }
    if (tris.numTris >= 6)
    {
        sdf = min(res.sdf, udTriangle2(tris.triangles[5], p));
        if (sdf < res.sdf) res.triI = 5;
        res.sdf = sdf;
    }

    return res;
}

struct CheckRayHitsTriangle
{
    bool hits;
    int triIndex;
    float d;
};

// steps through solid voxel and detects hit with triangle
// start: worldPos of ray entry into voxel
// end: worldPos of ray exit out of voxel
CheckRayHitsTriangle hitsSurface(int3 mapPos, float3 start, float3 dir, float3 end, int t)
{
    CheckRayHitsTriangle hits;
    VoxelTris triangles = generateTriangle(mapPos, t);
    if (triangles.numTris == 0)
    {
        hits.hits = false;
        return hits;
    }
    //float maxDst = distance(start, end) - epsilon;
    float maxDst = length(end) - epsilon;
    float d = 0 + epsilon;
    while (d < maxDst)
    {
        float3 p = start + dir * d;
        SDFTriRes res = sdfTris(triangles, p);
        d += res.sdf;
        if (res.sdf < epsilon)
        {
            hits.hits = true;
            hits.triIndex = res.triI;
            hits.d = d;
            return hits;
        }
    }
    hits.hits = false;
    return hits;
}

float3 getVoxelExitOffset(float3 sideDist, float3 deltaDist)
{
    if (sideDist.x < sideDist.y) {
        if (sideDist.x < sideDist.z) {
            return float3(deltaDist.x, 0, 0);
        }
        else {
            return float3(0,0,deltaDist.z);
        }
    }
    else {
        if (sideDist.y < sideDist.z) {
            return float3(0,deltaDist.y,0);
        }
        else {
            return float3(0,0,deltaDist.z);
        }
    }
}

bool isVoxelInBrushRadius(int3 mapPos)
{
    int3 offset = mapPos - mapPosCenter[0];
    return (offset.x >= -_BrushSize && offset.x <= _BrushSize
        && offset.y >= -_BrushSize && offset.y <= _BrushSize
        && offset.z >= -_BrushSize && offset.z <= _BrushSize);
}

void terraform(int3 mapPos, int2 id, int width, int height)
{
    if (id.x == width / 2 && id.y == height / 2)
    {
        for (int x = -_BrushSize; x <= _BrushSize; x++)
        {
            for (int y = -_BrushSize; y <= _BrushSize; y++)
            {
                for (int z = -_BrushSize; z <= _BrushSize; z++)
                {
                    int3 offset = int3(x, y, z);
                    if (length(offset + float3(1, 1, 1) / 2) > _BrushSize) continue;
                    float dis = length(offset);
                    Density[mapPos + offset + int3(1, 1, 1) * 1000 / 2] += _BrushStrength * exp(-dis / _BrushSize) * _Terraforming;
                }
            }
        }
    }
    /*float dis = distance(float3(mapPosCenter[0]), float3(mapPos));
    int3 offset = mapPos - mapPosCenter[0];
    if (offset.x >= -_BrushSize && offset.x <= _BrushSize
        && offset.y >= -_BrushSize && offset.y <= _BrushSize
        && offset.z >= -_BrushSize && offset.z <= _BrushSize)
    {
        float density = Density[mapPos + int3(1, 1, 1) * 1000 / 2];
        density += _BrushStrength * exp(-dis);
        Density[mapPos + int3(1, 1, 1) * 1000 / 2] = max(min(density, -1), 1);
    }*/
    /*if (isVoxelInBrushRadius(mapPos))
    {
        float dis = length(mapPos - mapPosCenter[0]);
        float density = Density[mapPos + int3(1, 1, 1) * 1000 / 2];
        density += _BrushStrength * exp(-dis / _BrushSize);
        if (density < -1) density = -1;
        if (density > 1) density = 1;
        Density[mapPos + int3(1, 1, 1) * 1000 / 2] = 1;
    }*/
}

float3 barycentricCoords(Triangle t, float3 P)
{
    float3 A = t.vertexA.position;
    float3 B = t.vertexB.position;
    float3 C = t.vertexC.position;

    float baryA = ((B.y - C.y) * (P.x - C.x) + (C.x - B.x) * (P.y - C.y)) / ((B.y - C.y) * (A.x - C.x) + (C.x - B.x) * (A.y - C.y));
    float baryB = ((C.y - A.y) * (P.x - C.x) + (A.x - C.x) * (P.y - C.y)) / ((B.y - C.y) * (A.x - C.x) + (C.x - B.x) * (A.y - C.y));
    float baryC = 1 - baryA - baryB;
    return float3(baryA, baryB, baryC);
}

struct RaymarchDDAResult
{
    int3 mapPos;
    bool miss;
    float pathLength; // distance to solid voxel entry face (of the cube representing the voxel, not the triangles)
    int triIndex;
    float voxelD; // how far the ray travels inside solid voxel before hitting a triangle

    bool isWaterRefracted;
    float3 waterSurfaceNorm;
    float3 waterRefractedDir;
    float totalDistThroughWater;
};

RaymarchDDAResult raymarchDDA(float3 o, float3 dir, int maxStepCount)
{
    // https://www.shadertoy.com/view/4dX3zl
    float3 p = o;
    // which box of the map we're in
    int3 mapPos = int3(floor(p));
    // length of ray from one xyz-side to another xyz-sideDist
    float3 deltaDist = abs(float3(1, 1, 1) * length(dir) / dir);
    int3 rayStep = int3(sign(dir));
    // length of ray from current position to next xyz-side
    float3 sideDist = (sign(dir) * (float3(mapPos.x, mapPos.y, mapPos.z) - o) + (sign(dir) * 0.5) + 0.5) * deltaDist;
    bool3 mask;
    bool miss = false;
    float pathLength = 0;
    CheckRayHitsTriangle terrainHits, waterHits;
    bool isWaterRefracted = false;
    float3 waterSurfaceNorm = float3(0, 0, 0);
    float3 waterRefractedDir = float3(0, 0, 0);
    float totalDistThroughWater = 0;
    bool isTravelingThroughWater = false;
    float3 waterEnterPos = float3(0, 0, 0);
    for (int i = 0; i < maxStepCount; i++) {
        ///////////////////
        // Hit Detection //
        ///////////////////
        float3 startPoint = o + dir * pathLength;
        float3 travelDir = getVoxelExitOffset(sideDist, deltaDist);
        float3 endPoint = startPoint + travelDir;
        float maxDstThroughVoxel = length(travelDir);

        // Increament dis through water
        //if (isTravelingThroughWater && !waterHits.hits)
        //{
        //   totalDistThroughWater += maxDstThroughVoxel;
        //}

        terrainHits = hitsSurface(mapPos, startPoint, dir, endPoint, 0); // check terraing hit
        waterHits = hitsSurface(mapPos, startPoint, dir, endPoint, 1); // check water hit

        float3 waterSurfaceHitPoint = o + dir * (pathLength + waterHits.d);

        if (waterHits.hits)
        {
            // water surface normal
            VoxelTris waterMeshTris = generateTriangle(mapPos, 1); // water mesh
            Triangle wT = waterMeshTris.triangles[waterHits.triIndex];
            float3 triCoords = barycentricCoords(wT, waterSurfaceHitPoint);
            waterSurfaceNorm = normalize(wT.vertexA.normal * triCoords.x + wT.vertexB.normal * triCoords.y + wT.vertexC.normal * triCoords.z);
        }

        // Case 1: terrain Voxel only
        if (terrainHits.hits && !waterHits.hits)
        {
            // no water will be rendered since terrain is opaque
            if (isTravelingThroughWater)
            {
                float3 terrainSurfaceHitPoint = o + dir * (pathLength + terrainHits.d);
                totalDistThroughWater += distance(waterEnterPos, terrainSurfaceHitPoint);
            }
            break;
        }
        // Case 2: water Voxel only
        else if (!terrainHits.hits && waterHits.hits)
        {
            // water is translucent, so continue ray marching with refracted ray
            //waterSurfaceNorm = calculateNormal(mapPos);

            float lookDirRelToWaterSurface = dot(waterSurfaceNorm, dir);
            if (lookDirRelToWaterSurface < 0)
            {
                // entering water mesh
                float maxDst = distance(startPoint, endPoint) - epsilon;
                //totalDistThroughWater += maxDst - waterHits.d;
                isTravelingThroughWater = true;
                waterEnterPos = waterSurfaceHitPoint;
            }
            else
            {
                // exiting water mesh
                // distance traveled till this voxel
                totalDistThroughWater += distance(waterEnterPos, waterSurfaceHitPoint);
                isTravelingThroughWater = false;
            }

            //float _WaterRefractionIndex = 1.333;
            //waterRefractedDir = normalize(refract(dir, waterSurfaceNorm, _WaterRefractionIndex));
            waterRefractedDir = normalize(lerp(dir, -waterSurfaceNorm, 0.5));
            isWaterRefracted = true;
            // update deltaDist, rayStep, sideDist
            //deltaDist = abs(float3(1, 1, 1) * length(waterRefractedDir) / waterRefractedDir);
            //rayStep = int3(sign(waterRefractedDir));
            //sideDist = (sign(waterRefractedDir) * (float3(mapPos.x, mapPos.y, mapPos.z) - o) + (sign(waterRefractedDir) * 0.5) + 0.5) * deltaDist;
            // store hit and refraction details
            // continue raymarching
        }
        // Case 3: Neither terrain voxel nor water voxel
            // continue raymarching
        // Case 4: Both terrain voxel and water voxel
        else if (terrainHits.hits && waterHits.hits)
        {
            // Case 4A: terrain hit before water
            if (terrainHits.d < waterHits.d)
            {
                if (isTravelingThroughWater)
                {

                }
                break;
            }
            else {
                // Case 4B: water hit before terrain
                isWaterRefracted = true;
                totalDistThroughWater += terrainHits.d - waterHits.d;
                isTravelingThroughWater = true;
                break;
            }
        }
        //////////////////////////
        // Continue raymarching //
        //////////////////////////
        if (sideDist.x < sideDist.y) {
            if (sideDist.x < sideDist.z) {
                pathLength = sideDist.x;
                sideDist.x += deltaDist.x;
                mapPos.x += rayStep.x;
                mask = bool3(true, false, false);
            }
            else {
                pathLength = sideDist.z;
                sideDist.z += deltaDist.z;
                mapPos.z += rayStep.z;
                mask = bool3(false, false, true);
            }
        }
        else {
            if (sideDist.y < sideDist.z) {
                pathLength = sideDist.y;
                sideDist.y += deltaDist.y;
                mapPos.y += rayStep.y;
                mask = bool3(false, true, false);
            }
            else {
                pathLength = sideDist.z;
                sideDist.z += deltaDist.z;
                mapPos.z += rayStep.z;
                mask = bool3(false, false, true);
            }
        }
        if (i == maxStepCount - 1)
        {
            miss = true;
        }
    }

    RaymarchDDAResult result;
    result.mapPos = mapPos;
    result.miss = miss;
    result.pathLength = pathLength;
    //result.normal = normalize(hits.tri.vertexA.normal + hits.tri.vertexB.normal + hits.tri.vertexC.normal);
    result.triIndex = terrainHits.triIndex;
    result.voxelD = terrainHits.d;
    result.isWaterRefracted = isWaterRefracted;
    result.waterSurfaceNorm = waterSurfaceNorm;
    result.waterRefractedDir = waterRefractedDir;
    result.totalDistThroughWater = totalDistThroughWater;
    return result;
}

bool isShadow(Ray camRay, float3 normal, float3 hitPoint)
{
    //float3 shadowRayDir = normalize(reflect(-camRay.direction, normal));
    float3 shadowRayDir = -_LightDirection;
    float3 o = hitPoint - camRay.direction * epsilon * 100;
    RaymarchDDAResult shadowResult = raymarchDDA(o + shadowRayDir * (epsilon * 2), shadowRayDir, MAX_SHADOW_RAY_VOX_TRAVERSE_COUNT);
    return !shadowResult.miss;
}

static const float maxFloat = 3.402823466e+38;

// https://github.com/SebLague/Solar-System/blob/Development/Assets/Scripts/Celestial/Shaders/Includes/Math.cginc
float2 raySphere(float3 sphereCentre, float sphereRadius, float3 rayOrigin, float3 rayDir) {
    float3 offset = rayOrigin - sphereCentre;
    float a = 1; // Set to dot(rayDir, rayDir) if rayDir might not be normalized
    float b = 2 * dot(offset, rayDir);
    float c = dot(offset, offset) - sphereRadius * sphereRadius;
    float d = b * b - 4 * a * c; // Discriminant from quadratic formula

    // Number of intersections: 0 when d < 0; 1 when d = 0; 2 when d > 0
    if (d > 0) {
        float s = sqrt(d);
        float dstToSphereNear = max(0, (-b - s) / (2 * a));
        float dstToSphereFar = (-b + s) / (2 * a);

        // Ignore intersections that occur behind the ray
        if (dstToSphereFar >= 0) {
            return float2(dstToSphereNear, dstToSphereFar - dstToSphereNear);
        }
    }
    // Ray did not intersect sphere

    return float2(maxFloat, 0);
}

float densityAtPoint(float3 densitySamplePoint)
{
    float heightAboveSurface = length(densitySamplePoint - planetCenter) - _OceanRadius;
    float height01 = heightAboveSurface / (_AtmosphereRadius - _OceanRadius);
    return exp(-height01 * _AtmosphereDensityFalloff) * (1 - height01);
}

float opticalDepth(float3 rayOrigin, float3 rayDir, float rayLength)
{
    float3 densitySamplePoint = rayOrigin;
    float stepsize = rayLength / (_OpticalDepthSteps - 1);
    float opticalDepth = 0;
    for (int i = 0; i < _OpticalDepthSteps; i++)
    {
        float localDensity = densityAtPoint(densitySamplePoint);
        opticalDepth += localDensity * stepsize;
        densitySamplePoint += rayDir * stepsize;
    }
    return opticalDepth;
}

float3 calculateLight(float3 rayOrigin, float3 rayDir, float3 rayLength, float3 originalCol)
{
    float3 inScatterPoint = rayOrigin;
    float stepSize = rayLength / (_AtmosphereSteps - 1);
    float3 inScatterLight = 0;
    float viewRayOpticalDepth = 0;

    for (int i = 0; i < _AtmosphereSteps; i++)
    {
        float sunRayLength = raySphere(planetCenter, _AtmosphereRadius, inScatterPoint, -_LightDirection).y;
        float sunRayOpticalDepth = opticalDepth(inScatterPoint, -_LightDirection, sunRayLength);
        viewRayOpticalDepth = opticalDepth(inScatterPoint, -rayDir, stepSize * i);
        float3 transmittance = exp(-(sunRayOpticalDepth + viewRayOpticalDepth) * _ScatterCoefficients);
        float localDensity = densityAtPoint(inScatterPoint);
        inScatterLight += localDensity * transmittance * _ScatterCoefficients * stepSize;
        inScatterPoint += rayDir * stepSize;
    }
    float originalColTransmittance = exp(-viewRayOpticalDepth);
    return (originalCol * originalColTransmittance) + inScatterLight * float3(1.1,1.1,1.1) + originalCol;
}

/*int findMatchingTriangleIndex(Triangle t, Triangle tris[6], int numTris)
{
    if (numTris == 0 || numTris >= 6) return -1;
    int minI = 0;
    float minDot = 10000;
    for (int i = 0; i < numTris; i++)
    {
        float vertexADot = abs(dot(t.vertexA.position, tris[i].vertexA.position));
        float vertexBDot = abs(dot(t.vertexB.position, tris[i].vertexB.position));
        float vertexCDot = abs(dot(t.vertexC.position, tris[i].vertexC.position));
        float currDot = vertexADot + vertexBDot + vertexCDot;
        if (currDot < minDot)
        {
            minDot = currDot;
            minI = i;
        }
    }

    return minI;
}*/

float2 sphericalToUV(float3 p)
{
    // http://raytracerchallenge.com/bonus/texture-mapping.html
    float theta = atan2(p.x, p.z);
    float3 vec = p - planetCenter;
    float radius = length(vec);
    float phi = acos(p.y / radius);
    float raw_u = theta / (2 * PI);
    float u = 1 - (raw_u + 0.5);
    float v = 1 - phi / PI;
    return float2(u, v);
}

float sandNoise(float3 p)
{
    float grainySandNoise = max((ridgedNoise2(p * 10, 3, 2, 1.5)) * 0.5 + 0.5, 0.99);
    //float wavySandNoise = max(( sin((hitPoint.x+hitPoint.y+hitPoint.z) * 10) + ridgedNoise(hitPoint * 2)) * 0.5 + 0.5, 0.1);
    return grainySandNoise;
}

float3 GetColorAtRaymarchResult(RaymarchDDAResult res, Ray camRay)
{
    float3 color = float3(0, 0, 0);
    float3 surfaceColor = float3(0, 0, 0);
    float3 voxelColor = float3(0, 0, 0);
    float3 diffuseColor = float3(0, 0, 0);
    float disToSurface = 0;
    float3 hitPoint = camRay.origin + camRay.direction * (res.pathLength + res.voxelD);

    if (res.isWaterRefracted)
    {
        float depthAmt = saturate(1-exp(_WaterDensityFalloff * -res.totalDistThroughWater));
        return lerp(_WaterColorShallow, _WaterColorDeep, depthAmt);
        //return res.waterSurfaceNorm * 0.5 + 0.5;
    }

    if (!res.miss) {
        VoxelTris vt = generateTriangle(res.mapPos, 0); // terrain
        Triangle t = vt.triangles[res.triIndex];
        float3 triCoords = barycentricCoords(t, hitPoint);

        // If flatshading
        float3 normal = calculateNormal(res.mapPos);
        // if smooth shading
        normal = normalize(t.vertexA.normal * triCoords.x + t.vertexB.normal * triCoords.y + t.vertexC.normal * triCoords.z);

        // material
        float sandNoiseDisappearingFallOff = 0.1; // higher = sooner it disappears
        float sandNois = lerp(1, sandNoise(hitPoint), exp(sandNoiseDisappearingFallOff * -abs(res.pathLength)) );
        //float sandFadeOutDis = 10;
        //if (res.pathLength < sandFadeOutDis)
        { // ignore if camera is too far away
            //float2 off = float2(0.01, 0);
            //float3 sandNorm = normalize(float3(sandNoise(hitPoint + off.xyy) - sandNoise(hitPoint - off.xyy),
            //    sandNoise(hitPoint + off.yxy) - sandNoise(hitPoint - off.yxy),
            //    sandNoise(hitPoint + off.yyx) - sandNoise(hitPoint - off.yyx)));

            //normal = normalize(normal + sandNorm);
        }

        disToSurface = res.pathLength + res.voxelD;
        float diff = dot(normal, -_LightDirection);
        float diffIntensity = 1;
        //voxelColor = getColorAtVoxel(hitPoint);

        //voxelColor = SandTexture.SampleLevel(samplerSandTexture, triCoords.xy, 0);
        
        voxelColor = (sandNois) * _SandColor;

        float3 diffuse = float3(1, 1, 1) * diffIntensity;
        diffuseColor = saturate(diff * diffuse);

        float fogAmt = pow(exp(-1 / res.pathLength), 10);
        float3 fog = fogAmt * float3(1, 1, 1);

        // shadow
        float3 shadowColor = float3(1, 1, 1);
        bool shadow = isShadow(camRay, normal, hitPoint);
        if (shadow) shadowColor *= 0.5;

        surfaceColor = (diffuseColor + _AmbientColor) * voxelColor * shadowColor;
        

        //res.mapPos.x == mapPosCenter[0].x && res.mapPos.y == mapPosCenter[0].y && res.mapPos.z == mapPosCenter[0].z
        /*if (isVoxelInBrushRadius(res.mapPos))
        {
            float brushdis = distance(res.mapPos, mapPosCenter[0]);
            color = color + float3(1, 0, 0) * (1 - brushdis / _BrushSize);
        }*/

        //color = float3(1, 1, 1);
        //color = float3(1, 1, 1);
        // depth blur
        //color *= (1 - d / maxStepCount * 1.75);
        color = normal * 0.5 + 0.5;
    }

    color = surfaceColor;

    // ocean
    /*float waveNoise = ridgedNoiseWave(hitPoint);
    float2 oceanRaySphere = raySphere(planetCenter, _OceanRadius, camRay.origin, camRay.direction);
    float3 oceanColor = float3(0, 0, 0);
    float disToWaterSurface = oceanRaySphere.x;
    float disThroughOcean = 0;
    float oceanNormalNoise = waveNoise * 10;
    float3 oceanNormal = hitPoint - planetCenter;
    if (oceanRaySphere.y > 0 && disToWaterSurface < MAX_RAY_VOX_TRAVERSE_COUNT/2)
    {
        // Ocean not in path of ray

        if (res.miss)
        {
            disThroughOcean = oceanRaySphere.y / (_OceanRadius * 2);
            oceanNormal = normalize(oceanNormal + oceanNormalNoise * exp(1/ disThroughOcean));

            oceanColor = lerp(_WaterColorShallow, _WaterColorDeep, disThroughOcean);
            oceanColor = saturate(oceanColor);
            color = oceanColor;
        }
        else if (disToWaterSurface < disToSurface)
        {
            // Ocean visible
            disThroughOcean = disToSurface - disToWaterSurface;
            oceanNormal = normalize(oceanNormal + oceanNormalNoise * exp(1 / disThroughOcean));

            float disT = 1 - disToWaterSurface / disToSurface;
            //if (disToWaterSurface > 0)
            {
                //float2 uv = sphericalToUV(hitPoint) * 100;
                //oceanColor = WaterTexture.SampleLevel(samplerWaterTexture, uv, 0);
            }
            //else 
            {
                oceanColor = lerp(_WaterColorShallow, _WaterColorDeep, disT);
            }
            // wavebreak
            //if (disThroughOcean <= _WaveBreakDepth)
            //{
            //    oceanColor = float3(1, 1, 1);
            //    color = saturate(oceanColor * 1 / disThroughOcean);
            //}
            //else
            {
                // diffuse
                float diff = max(dot(oceanNormal, -_LightDirection), 0.0);
                float3 diffuse = diff * _SunColor;
                // specular
                float3 reflectDir = reflect(-_LightDirection, oceanNormal);
                float spec = pow(max(dot(camRay.direction, reflectDir), 0.0), 32);
                float3 specular = _SpecularStrength * spec * _SunColor;
                //oceanColor *= waveNoise;
                oceanColor = saturate((float3(1, 1, 1) * 0.25 + diffuse + specular) * oceanColor);
                //surfaceColor = (diffuseColor + _AmbientColor) * voxelColor * shadowColor;
                color = lerp(oceanColor, surfaceColor, saturate(1 / disThroughOcean));
            }
        }
    }*/
    
    // atmoshpere
    /*float2 atmosphereSphere = raySphere(planetCenter, _AtmosphereRadius, camRay.origin, camRay.direction);
    float dstToAtmosphere = atmosphereSphere.x;
    float dstThroughAtmosphere = disToSurface - dstToAtmosphere;
    if (res.miss) dstThroughAtmosphere = atmosphereSphere.y;
    if (dstThroughAtmosphere > 0)
    {
        const float atmos_epsilon = 0.0001;
        float3 pointInAtmosphere = camRay.origin + camRay.direction * (dstToAtmosphere + atmos_epsilon);
        color = calculateLight(pointInAtmosphere, camRay.direction, dstThroughAtmosphere - atmos_epsilon * 2, color);
    }*/

    return color;
}

float3 raymarchTri(Ray ray)
{
    float d = 0;
    float maxDst = 1000;
    bool hit = false;
    while (d < maxDst)
    {
        float3 p = ray.origin + ray.direction * d;
        float sdf = udTriangle(float3(0,0,0), float3(10,0,0), float3(0,10,0), p);
        //float sdf = sdSphere(p, 30, planetCenter);
        if (sdf < epsilon)
        {
            hit = true;
            break;
        }
        d += sdf;
    }
    if (!hit) return float3(0, 0, 0);
    return normalize(d/maxDst) * 0.5 + 0.5;
}

float gaussian(int2 p, float std)
{
    return 1 / (2 * PI * std * std) * exp(-(p.x * p.x + p.y * p.y) / (2 * std * std));
}

void blur(uint2 id, uint width, uint height)
{
    float4 result = float4(0,0,0,0);
    int blurRadius = 0;
    int count = 0;
    for (int x = -blurRadius; x <= blurRadius; x++)
    {
        for (int y = -blurRadius; y <= blurRadius; y++)
        {
            int2 offset = id.xy + int2(x, y);
            if (offset.x < 0 || offset.y < 0 || offset.x >= width || offset.y >= height) continue;
            float d = distance(id.xy, offset.xy);
            result += Destination[id.xy + int2(x, y)] * gaussian(int2(x, y), 1);
            count++;
        }
    }
    //Destination[id.xy] = result;
}

bool shouldRayMarch(uint2 id, uint width, uint height)
{
    if (id.x == width / 2 && id.y == height / 2) return true;
    float off = distance(int2(width/2, height/2), id.xy);
    if (off <= _BrushSize) return true;
    bool odds = (_RenderOdds && !(id.x % 2 == 0 && id.y % 2 == 0));
    bool evens = (!_RenderOdds && (id.x % 2 == 0 && id.y % 2 == 0));
    return odds || evens;
}

[numthreads(numThreads, numThreads, 1)]
void CSMain(uint2 id : SV_DispatchThreadID)
{
    uint width, height;
    Destination.GetDimensions(width, height);

    if (shouldRayMarch(id, width, height))
    {
        float2 uv = id.xy / float2(width, height);
        uv += float2(sin(_Time) / width, cos(_Time) / height) * 0.01;

        // Background gradient

        // Raymarching:
        Ray ray = CreateCameraRay(uv * 2 - 1);

        float4 result = float4(ray.direction * 0.5 + 0.5, 0);

        RaymarchDDAResult res = raymarchDDA(ray.origin, ray.direction, MAX_RAY_VOX_TRAVERSE_COUNT);

        if (id.x == width / 2 && id.y == height / 2)
        {
            mapPosCenter[0] = res.mapPos;
        }

        result.xyz = GetColorAtRaymarchResult(res, ray);

        //result.xyz = raymarchTri(ray);

        Destination[id.xy] = result;
        blur(id, width, height);

        if (_Terraforming != 0)
        {
            terraform(res.mapPos, id, width, height);
        }
    }
}

[numthreads(numThreads, numThreads, numThreads)]
void DensityKernel(uint3 id : SV_DispatchThreadID)
{
    Density[id.xyz] = getNoise(id);
    WaterDensity[id.xyz] = getWaterNoise(id);
}
