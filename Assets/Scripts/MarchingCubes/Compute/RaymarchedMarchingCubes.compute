#pragma kernel CSMain

#include "MarchingCubes.compute"

RWTexture2D<float4> Destination;
RWStructuredBuffer<uint> voxels;

float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;
float3 _LightDirection; // must be normalized!
// colors
float3 _AmbientColor;
float3 _GrassColor;
float3 _SandColor;
float3 _WaterColor;
float3 _DirtColor;

static const float epsilon = 0.001;
static const int maxStepCount = 500;

//float planetRadius = 100; // make sure they are synced!
static const float3 planetCenter;

struct Ray {
    float3 origin;
    float3 direction;
};

Ray CreateRay(float3 origin, float3 direction) {
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    return ray;
}

Ray CreateCameraRay(float2 uv) {
    float3 origin = mul(_CameraToWorld, float4(0, 0, 0, 1)).xyz;
    float3 direction = mul(_CameraInverseProjection, float4(uv, 0, 1)).xyz;
    direction = mul(_CameraToWorld, float4(direction, 0)).xyz;
    direction = normalize(direction);
    return CreateRay(origin, direction);
}

float sdSphere(float3 p, float r, float3 c) { return length(p - c) - r; }

float dot2(float3 v) { return dot(v, v); }
float udTriangle(float3 v1, float3 v2, float3 v3, float3 p)
{
    // prepare data    
    float3 v21 = v2 - v1; float3 p1 = p - v1;
    float3 v32 = v3 - v2; float3 p2 = p - v2;
    float3 v13 = v1 - v3; float3 p3 = p - v3;
    float3 nor = cross(v21, v13);

    return sqrt( // inside/outside test    
        (sign(dot(cross(v21, nor), p1)) +
            sign(dot(cross(v32, nor), p2)) +
            sign(dot(cross(v13, nor), p3)) < 2.0)
        ?
        // 3 edges    
        min(min(
            dot2(v21 * clamp(dot(v21, p1) / dot2(v21), 0.0, 1.0) - p1),
            dot2(v32 * clamp(dot(v32, p2) / dot2(v32), 0.0, 1.0) - p2)),
            dot2(v13 * clamp(dot(v13, p3) / dot2(v13), 0.0, 1.0) - p3))
        :
        // 1 face    
        dot(nor, p1) * dot(nor, p1) / dot2(nor));
}
float udTriangle2(Triangle t, float3 p)
{
    return udTriangle(t.vertexA, t.vertexB, t.vertexC, p);
}


bool getVoxel(int3 c)
{
    /*float3 p = float3(c)+float3(1, 1, 1) * 0.5;
    const float3 off = float3(2134, 213, 24);
    float d = distance(p, planetCenter);
    //float height = (snoise(normalize(p) * scale)) * amplitude;
    float3 pp = p + noisePosition;
    float noise = lerpF(-1.0, 1.0, d / (100 * 2));
    //return noise + (ridgedNoise2(normalize(pp * surfaceNoiseScale), 3, 2.0, 2.0) * 2 - 1) * surfaceNoiseImpact < 0;*/
    return density(c) < 0;
    //return noise < 0;
    //int i = to1D(c.x, c.y, c.z);
    //if (i < 0 || i >= voxelsPerAxis * voxelsPerAxis * voxelsPerAxis) return false;
   // return voxels[i] != 0;
}

float3 getColorAtVoxel(int3 mapPos)
{
    float3 p = float3(mapPos)+float3(1, 1, 1) * 0.5;
    float planetHeight = distance(p, planetCenter) - 100;
    if (planetHeight < 0) return _WaterColor;
    if (planetHeight < 3) return _SandColor;
    if (planetHeight < 10) return _DirtColor;
    if (planetHeight < 15) return _GrassColor;
    return float3(1, 1, 1);

    /*const float3 off = float3(12, 1, -33);
    float3 pp = p + noisePosition;
    float noise = ridgedNoise2(normalize(pp * 0.1), 1, 2.0, 2.0) * 0.5;
    if (noise < 0.15) return _SandColor;
    if (noise < 0.25) return _DirtColor;
    return _GrassColor;*/
}

static const float MAX_FLOAT = 3.402823466e+38F;

float sdfTris(VoxelTris tris, float3 p, int3 mapPos)
{
    float sdf = udTriangle2(tris.triangles[0], p);
    if (tris.numTris >= 2) sdf = min(sdf, udTriangle2(tris.triangles[1], p));
    if (tris.numTris >= 3) sdf = min(sdf, udTriangle2(tris.triangles[2], p));
    if (tris.numTris >= 4) sdf = min(sdf, udTriangle2(tris.triangles[3], p));
    if (tris.numTris > 5) sdf = min(sdf, udTriangle2(tris.triangles[4], p));
    /*for (int i = 1; i < tris.numTris; i++)
    {
        t = tris.triangles[i];
        sdf = min(sdf, udTriangle(t.vertexA, t.vertexB, t.vertexC, p));
    }*/

    return sdf;
}

// steps through solid voxel and detects hit with triangle
// start: worldPos of ray entry into voxel
// end: worldPos of ray exit out of voxel
bool hitsSurface(int3 mapPos, float3 start, float3 dir, float3 end)
{
    VoxelTris triangles = generateTriangle(mapPos);
    if (triangles.numTris == 0) return false;
    float maxDst = distance(start, end) - epsilon;
    float d = 0 + epsilon;
    while (d < maxDst)
    {
        float3 p = start + dir * d;
        float sdf = sdfTris(triangles, p, mapPos);
        if (sdf < epsilon)
        {
            return true;
        }
        d += sdf;
    }
    return false;
}

float3 getVoxelExitOffset(float3 sideDist, float3 deltaDist)
{
    if (sideDist.x < sideDist.y) {
        if (sideDist.x < sideDist.z) {
            return float3(deltaDist.x, 0, 0);
        }
        else {
            return float3(0,0,deltaDist.z);
        }
    }
    else {
        if (sideDist.y < sideDist.z) {
            return float3(0,deltaDist.y,0);
        }
        else {
            return float3(0,0,deltaDist.z);
        }
    }
}

float3 raymarchDDA(float3 o, float3 dir)
{
    // https://www.shadertoy.com/view/4dX3zl
    float3 p = o;
    // which box of the map we're in
    int3 mapPos = int3(floor(p));
    // length of ray from one xyz-side to another xyz-sideDist
    float3 deltaDist = abs(float3(1, 1, 1) * length(dir) / dir);
    int3 rayStep = int3(sign(dir));
    // length of ray from current position to next xyz-side
    float3 sideDist = (sign(dir) * (float3(mapPos.x, mapPos.y, mapPos.z) - o) + (sign(dir) * 0.5) + 0.5) * deltaDist;
    bool3 mask;
    bool miss = false;
    float pathLength = 0;
    for (int i = 0; i < maxStepCount; i++) {
        if (hitsSurface(mapPos, o + dir * pathLength, dir, o + getVoxelExitOffset(sideDist, deltaDist))) break;
        if (sideDist.x < sideDist.y) {
            if (sideDist.x < sideDist.z) {
                pathLength = sideDist.x;
                sideDist.x += deltaDist.x;
                mapPos.x += rayStep.x;
                mask = bool3(true, false, false);
            }
            else {
                pathLength = sideDist.z;
                sideDist.z += deltaDist.z;
                mapPos.z += rayStep.z;
                mask = bool3(false, false, true);
            }
        }
        else {
            if (sideDist.y < sideDist.z) {
                pathLength = sideDist.y;
                sideDist.y += deltaDist.y;
                mapPos.y += rayStep.y;
                mask = bool3(false, true, false);
            }
            else {
                pathLength = sideDist.z;
                sideDist.z += deltaDist.z;
                mapPos.z += rayStep.z;
                mask = bool3(false, false, true);
            }
        }
        if (i == maxStepCount - 1)
        {
            miss = true;
        }
    }

    float d = distance(o, mapPos);

    float3 color;
    if (miss)
    {
        color = float3(0, 0, 0);
    }
    else {
        /*if (mask.x) {
            color = float3(0.5, 0.5, 0.5);
        }
        if (mask.y) {
            color = float3(1,1,1);
        }
        if (mask.z) {
            color = float3(0.75, 0.75, 0.75);
        }*/
        float3 planetNorm = normalize(mapPos - planetCenter);
        float diff = dot(planetNorm, _LightDirection);
        float diffIntensity = 1;
        float3 voxelColor = getColorAtVoxel(mapPos);
        float3 diffuseColor = float3(1, 1, 1) * diffIntensity;
        float3 diffuse = saturate(diff * diffuseColor);
        color = (diffuse + _AmbientColor) * voxelColor;
        //color = float3(1, 1, 1);
        //color = float3(1, 1, 1);
        // depth blur
        //color *= (1 - d / maxStepCount * 1.75);
    }
    return color;
}

float3 raymarchTri(Ray ray)
{
    float d = 0;
    float maxDst = 1000;
    bool hit = false;
    while (d < maxDst)
    {
        float3 p = ray.origin + ray.direction * d;
        float sdf = udTriangle(float3(0,0,0), float3(10,0,0), float3(0,10,0), p);
        //float sdf = sdSphere(p, 30, planetCenter);
        if (sdf < epsilon)
        {
            hit = true;
            break;
        }
        d += sdf;
    }
    if (!hit) return float3(0, 0, 0);
    return normalize(d/maxDst) * 0.5 + 0.5;
}


[numthreads(numThreads, numThreads, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    Destination.GetDimensions(width, height);

    float2 uv = id.xy / float2(width, height);

    // Background gradient

    // Raymarching:
    Ray ray = CreateCameraRay(uv * 2 - 1);
    float rayDst = 0;
    int marchSteps = 0;

    float4 result = float4(ray.direction * 0.5 + 0.5, 0);


    result.xyz = raymarchDDA(ray.origin, ray.direction);
    //result.xyz = raymarchTri(ray);

    Destination[id.xy] = result;
}
